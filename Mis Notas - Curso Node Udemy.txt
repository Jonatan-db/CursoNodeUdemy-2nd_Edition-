
	Repositorio Git de los ejercicios:	
		https://github.com/Jonatan-db/CursoNodeUdemy-2nd_Edition-
		
	Descargar Node.js:
		Https://nodejs.org/en/			Instalar la versión "Current"
	
	Verificar que se instaló, ejecutando desde la consola: node -v
	
	
	¿Que es Node?
		Es un runtime de javascript, que usa el motor V8 y que corre desde la linea de comandos de Windows.
	
	¿Que es V8?
		Es un motor de javascript open source escrito en C++, que toma codigo javascript y lo compila en código maquina. 
		V8 se utiliza dentro de Chrome y de Node.js.
		
	Consola de Node.js en Windows y en Chrome:
		Es la misma que se encuentra yendo a las opciones de desarrollador de Chrome (F12), solapa Console.
		Puede recibir los mismos comandos que Node desde la consola de Windows.
		
		Diferencias:
			Node tiene caracteriscas como manipulación del sistema de archivos.
			El navegador tiene caracteristicas para manipulación de lo que se muestra en la ventana del navegador.
			
			Chrome			Node
			window			global		
			document		process		
			
			Objeto window, similar a global en Node:
				En el navegador se utiliza el objeto window cuando se trabaja con javascript, window es el objeto global que
					almacena todo a lo que se tiene acceso (manipulación de css, variables de Google analitycs, etc)
				Cualquier variable que se crea en javascript se encuentra dentro del objeto window.
			
			Objeto global, similar a window en Chrome:
				Contiene casi lo mismo que el objeto window, con algunas excepciones.
			
			Objeto document, similar a process en Node:
				Almacena una referencia al DOM, por lo que contiene todo lo que se muestra en la pagina.
				Por medio de document se puede modificar todo lo que contiene la pagina web actual.
			
			Objeto process, similar a document en Chrome:
				Contiene información acerca del proceso de Node que se está ejecutando.
				También provee métodos que permiten, entre otras cosas, finalizar el proceso de Node actual: process.exit(0);

	Los proyectos se crean en carpetas, cada proyecto vive dentro de su propia carpeta.
	
	String templates gracias a EC6:
		fs.appendFileSync('saludos.txt', `Bienvenido ${variable}!`); ** Importante: Se utiliza una comilla especial, no la simple.
		
	Módulos:
		Son librerías de funcionalidad, Node ya provee muchos.
		Se pueden importar nuevos, descargarlos de internet, etc.
		Para ver la lista de módulos disponibles en Node consultar: nodejs.org/api
		Para utilizarlos se deben importar utilizando "require":  
			const moduloimportado = require('modulodeseado');	//Importo el módulo. Se declara con const ya que no se modificará.
			moduloimportado.metodo();										//Utilizo una funcionalidad incluída en él, en este caso ejecuto un método.
	
	"module":
		Variable global que existe dentro de todos los archivos de una aplicación de Node, la cual contiene varios objetos y propiedades.
		"exports": es un objeto al que se le pueden agregar propiedades y métodos, las cuales pueden ser accedidas cuando se importa el módulo.
			Ejemplo:
				Creo un archivo llamado archivomodulo.js con esto:
					module.exports.metododentrodelmodulo = () => { console.log('algun valor') };
				Desde el archivo que va a importar para consumir al modulo hago lo siguiente:
					const modulo = require('./archivomodulo.js');
					modulo.metododentrodelmodulo();	// Se ejecuta el metodo expuesto por el modulo y se muestra el string 'algun valor' en la consola.

	NPM:		Node package manager
		Se utiliza para obtener, instalar y generar módulos
		npm -v		Muestra la versión de npm instalada.
		npm init		Establece la carpeta de trabajo actual como un módulo creando simplemente un archivo llamado: "package.json".
						NPM mediante un asistente, solicita información sobre el proyecto y la guarda en el archivo package.json.
		package.json	Entre otras cosas, lo mas importante es que especifica los módulos de los que depende mi aplicación.
		npmjs.com		Web donde se pueden buscar modulos, leer sobre su uso y contenido, comentarios, estadisticas, etc.
		npm install					Lee el arhcivo package.json y crea una carpeta node-modules donde descarga y descomprime todas las "dependencias".
		npm install modulo 			Crea una carpeta llamada node-modules, donde crea otra con el nombre del modulo especificado y descarga su contenido.
		npm install modulo --save 	Instala el módulo y además lo agrega como dependencia de nuestro proyecto, en el archivo package.json existente.
												Luego de esto se puede hacer require del módulo desde nuestra aplicación.
												Cuando Node intenta hacer un require, primero busca entre los módulos del core de Node, 
												luego busca en la carpeta local de nuestro proyecto llamada node-modules.
												Si no se utiliza "--save", igual se crea la carpeta node-modules y se puede hacer requiere y utilizar el módulo,
												pero si se cambia de lugar la aplicación y no se mueve también la carpeta node-modules, al ejecutar la aplicación
												va a arrojar el error de que no encuentra el módulo, por mas que se ejecute npm install, ya que npm install
												se basa en las dependencias especificadas en el archivo package.json para crear la carpeta node-modules y 
												descargar e instalar ahí los módulos especificados.
		npm install:		Lee el archivo package.json y crea la carpeta node-modules, donde descarga y descomprime todos los módulos dependientes.
		npm run nombreDeScript		Ejecuta el o los comandos especificados en el objeto dentro de la sección scripts del package.json 
												que tenga nombre "nombreDeScript".
		npm start			Igual que npm run "nombreDeScript", salvo que como "Start" es uno de los pasos del ciclo de vida de una app de node, si el
								script existe (Se creó la entrada "start" dentro del objeto scripts) se puede ejecutar sin especificar "run".
								Si no se crea la sección "start" dentro del objeto Scripts del package.json, npm start va a ejecutar "node server.js".
		npm test			Funciona como npm start.
		
	Restart automático de apps cuando se detecta un cambio en el código:
		Cuando se modifica el código fuente, por lo general hay que ir a la consola a detener y volver a iniciar la aplicación (C:\>node miapp.js).
		Para solucionar esto se puede utilizar el comando Nodemon.
		Nodemon se debe instalar de manera global, mediante "npm install nodemon -g", ya que se utiliza para ejecutar apps en lugar de usar "node app.js" y se utiliza como un comando mas:
			C:\>nodemon app.js		A partir de este momento, cada vez que se modifique el fuente de la aplicación, 
												la misma se reiniciará automaticamente. 
												Por lo tanto, nodemon, no se agrega al archivo package.json ni se le realiza un require.
	
Getting Input From User 		- Sección 3, clase 13 -  https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525246?start=0

	"process.argv" contiene el conjunto de parámetros pasados al ejecutarse la aplicación: console.log(process.argv);
	Al ejecutar algo como "node app.js prueba", se puede acceder al comando "prueba" o cualquiera que se haya pasado, con:
		var comando = process.argv[2];
		console.log("Comando pasado: " + comando);
	
Simplified Input With Yargs	 - Sección 3, clase 14 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525248?start=0

	npm install yargs@4.7.1 --save				Instalo el módulo Yargs en cierta versión específica (especificar la versión es opcional)
															-- save: con esto se registra el módulo como dependencia en el archivo package.json.
	const yargs = require('yargs');				Importo el módulo
	var argv = yargs.argv;							Capturo los argumentos leídos por Yargs
	Ahora si ejecuto por ej:  node miapp.js --titulo="lala"		Voy a poder acceder a los parámetros pasados de la siguiente manera:
		console.log('argv.titulo');		--> Muestra 'lala'

Working With JSON				 - Sección 3, clase 15 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525250?start=0

	JSON:		Javascript object notation.		Representa con texto objetos javascript.
	Se puede convertir un objeto a un string utilizando JSON.stringify(objeto).
	Se puede convertir un string (en JSON) a objeto nuevamente utilizando JSON.parse(stringObjeto).
	
Adding and Saving Notes		- Sección 3, clase 16 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525252?start=0
 
	Uso de método filter de array:			var duplicates = miArray.filter( (nota) => nota.titulo === titulo);
														Es lo mismo que: var duplicates = miArray.filter( (nota) => { return nota.titulo === titulo; } );
 
Refactoring For Reusability		- Sección 3, clase 17 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525254?start=0

Removing a Note						- Sección 3, clase 18 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525256?start=0

Reading Notes and Reusability 	- Sección 3, clase 19 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525258?start=0
 
Debugging Node.js Applications - Sección 3, clase 20 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525260?start=0

	node inspect app.js			Ejecuta la aplicación en modo debug		*** NO FUNCIONA CON NODE V6!, se debe usar "node debug app.js".
	list(10)							Muestra las siguientes n lineas de código.
	n			(Next	)				Ejecuta las lineas una por una.
	c			(Continue)			Continua con la ejecución total de la aplicación.
	Ctrl+c 	(2 veces)			Fiinaliza el modo debug.
	repl(Revaluate print loop)	Este modo permite conocer y manipular el contenido de los objetos y variables (se pueden hacer sumas, consultas, etc.)
											Se sale del modo repl con Ctrl+C, lo que nos devuelve al modo debug.
	debugger;						Palabra clave que establece un breakpoint que se activará cuando se esté debugeando la aplicación (con inspect/debug).
											Un vez que se detiene la aplicación en este punto, se puede entrar al modo repl y ver el contenido de las variables.

Debugging via Chrome Dev Tools - Sección 3, clase 21 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525262?start=0

	node --inspect-brk app.js	(Solo a partir de node v.8) Ejecuta node en modo debug desde Chrome.	(https://nodejs.org/en/docs/inspector/)
												En V6 usar: node --inspect --debug-brk app.js 
										A partir de este momento, se debe abrir Chrome e ir a la url: chrome://inspect y hacer click en 
											"Open dedicated DevTools for Node".
										Una vez ahí, en la solapa Sources se puede ver el mismo código que cuando se accede en modo debug desde la consola ya
											se pueden establecer breakpoinst para debuggear y ejecutar el código linea por linea y demás.
										Con Escape se abre y cierra la consola inferior que funciona igual que el modo "repl", donde se puede ejecutar javascript.
	nodemon --inspect-brk app.js	Funciona de la misma manera, solo que la app se reiniciará cada vez que sea modificado el fuente pero la ventaja
													es que no hace falta reiniciar Chrome.

Listing Notes - Sección 3, clase 22 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525264?start=0

Requiring Arguments and Advanced Yargs - Sección 3, clase 23 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525266?start=0

	Más usos de Yargs:
		Se puede agregar a la utilización de Yargs, la llamada a los métodos command() y help():
			var argv = yargs.command('list', 'Muestra la lista de notas').help().argv;
				command() acepta varios parámetros, que permite definir una 'ayuda' en pantalla sobre como utilizar la app.
				Con la definición anterior, cuando se ejecute la app sin parámetro alguno, pero agregando '--help', va a aparecer una leyenda indicando 
				que se dispone del comando 'list', el cual 'Muestra la lista de notas'.
				Tambien se puede configurar por ejemplo el parámetro 'add' de la siguiente manera:
					var argv = yargs
					.command('add', 'Agrega una nueva nota', {
						title: {
							describe: 'Titutlo de la nota',
							demand: true,
							alias: 't'
						},
						body: {
								describe: 'Cuerpo de la nota',
								demand: true,
								alias: 'b'
							}
						})
					.help()
					.argv;
					De esta manera, se puede ejecutar por ejemplo: node app.js add -t=Titulo -b=Cuerpo
						o también: node app.js add --title=Titulo --body=Cuerpo
					También se puede especificar que title y body sean obligatorios.
	
Arrow Functions - Sección 3, clase 24 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525270?start=0
	
	Uso básico:
		var square = (x) => {
			var result = x * x;
			return result;
		}
		console.log(square(9));
		
	Uso resumido 'Expresion sintax':
		var square = (x) => x * x;
		console.log(square(9));
		
	Cuando la funcion arrow recibe solo un parámetro, se pueden omitir los paréntesis:
		var square = x => x * x;
		console.log(square(9));
		*	Si se esperan cero argumentos o mas de uno, se deben utilizar los parentesis, en el caso no esperar argumentos se dejan vacios: ()

	Diferencias usando funciones comunes y funciones arrow:
	Usando arrow functions dentro de un objeto, no se puede acceder a la palabra clave 'this' para referenciar propiedades del objeto
		ni tampoco se puede utilizar el objeto 'arguments' implicito de los métodos en javascript:
		var user = {
			name : 'Jony',
			sayHi: () => {
				console.log(`(arrow1)Hola ` + name);    	// Error:  name is not defined.
				console.log(`Hola ` + this.name);			// Hola undefined
			},
			sayHi2: (a, b) => {
				console.log("Parámetros recibidos: " + arguments);		
			}
		user.sayHi();							// Devuelve: Hola undefined
		user.sayHi2("lala", "lele");			// Devuelve: Parámetros recibidos: (Acá muestra el contenido del objeto process o global).
		
		Todo esto si se puede utilizar si el método del objeto es una función común, en un lugar de ser una arrow function:
				var user = {
					name : 'Jony',
					sayHi(dato, dato2) {
									console.log(`Hola ` + this.name);							// Devuelve: Hola Jony
									console.log("Parámetros recibidos: " + arguments);	// Devuelve: Parámetros recibidos: (la lista de parámetros pasados)
			}
		}
		
 
Section Intro - Sección 4, clase 25 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525274?start=0

Async Basics - Sección 4, clase 26 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525276?start=0

	Llamada asincronica básica:
		console.log('Iniciando app... ' + new Date().toTimeString());
		setTimeout( () => {
			console.log('Ejecución asincronica finalizada. ' + new Date().toTimeString());
		}, 2000);
		console.log('Finalizando app. ' + new Date().toTimeString());
	Con el uso de la función setTimeout se establece que el código pasado como primer argumento, se ejecute luego de la cantidad de milisegundos indicados como
		segundo argumento.
		Lo importante a tener en cuenta es que la ejecución de la aplicación continúa luego de pasar por la linea de setTimeout y no se queda bloqueada esperando
			a que pasen los 2 segundos para luego ejecutar el último console.log, esto es porque la llamada al console.log dentro de setTimeout es asincronica.
	La aplicación primero ejecutará la primera y última lineas y luego de 2 segundos ejecutará y mostrará el mensaje "Ejecución asincronica finalizada.".
	
Call Stack & Event Loop - Sección 4, clase 27 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525278?start=0

	Call stack:	
					Pila de llamadas donde se apilas las sentencias a ejecutar, comenzando por Main().
	Node APIs:
					Punto donde se almacenan las llamadas asincronicas hasta que éstas finalizan su ejecución o se les acaba el tiempo.
	Callback queue:
					Punto donde se almacenan las ejecuciónes asincronicas cuando están listas para ser ejecutadas.
					Ahí las funciones van a esperar a que el Event loop detecte que el call stack esté libre y cuando esto suceda entonces serán ejecutadas.
	Event Loop:
					Mecanismo que cada vez que detecta que el call stack está libre, ejecuta lo primero que esté encolado en el Callback queue.
					
Callback Functions & APIs - Sección 4, clase 28 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525280?start=0

	Función callback:		
							Es una función que se pasa como argumento a otra función y que cuando pasa algo en esta segunda función se ejecuta la primera pasada como argumento.

	Instalación de extensión de Chrome: JSON View, para ver resultados JSON formateados y poder colapsar sus nodos desde Chrome.
	
	Obtención de JSON con información de Google sobre una dirección utilizando la API de Google Maps desde Chrome:
		http://maps.googleapis.com/maps/api/geocode/json?address=18 de julio 754 garin buenos aires
	
	Instalación y uso del paquete (módulo) de npm "request" para hacer peticiones http de manera mas simple:
		npm install request --save
		
		Uso de request:
			request( objeto con propiedades varias (url, json, etc), callback);
				url: dirección a la que se hace el request
				json: parametro booleano para definir si el resultado se devuelve en formato json o no
				callback: funcion/metodo a ejecutar cuando se obtenga la respuesta desde la url indicada
								la firma de este metodo suele ser la siguiente:
									callback(error, response, body)
										donde:
											error: null si el servidor no devolvió ningún error
											response: booleano que indica si hubo una respuesta
											body: resultado de la respuesta (es un objeto por lo que se puede formatear usando JSON.stringify(body, undefined, 2) para verlo mas claramente).
							esta funcion se puede reemplazar por una funcion arrow, como está hecho en el ejemplo de mas abajo.
							
		Ejemplo de uso:
		
		const req = require('request');
		req(	{
					url: 'http://maps.googleapis.com/maps/api/geocode/json?address=18 de julio 754 garin buenos aires',
					json: true
				},
				(error, response, body) => {
					(error) ? console.log("Error: ", error) : null;
					console.log("Response: ", response && response.statusCode === 200);
					console.log("Body: ", body);
				}
			);
	
Pretty Printing Objects - Sección 4, clase 29 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525282?start=0

	Formateo de la representacion en string de un JSON utilizando el tercer parámetro de la llamada a JSON.stringify(objeto, opcionesDeFiltrado, identacion).
	
What's Makes up an HTTP Request? - Sección 4, clase 30 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525284?start=0

	Explicación de los parámetros recibidos y datos devueltos por Request.
		error:
								Objeto que almacena el error obtenido (si hay alguno, sino vuelve nulo) al realizar el request.
								
		response:
			statusCode:	Respuesta del servidor que indica que el estado (200= ok, 404= pagina no encontrada, 500=  servidor dañado, etc...).
								Es importante verificar el valor obtenido en esta propiedad al realizar el request, porque da información sobre si pudimos o no obtener lo que esperabamos del servidor.
			body:			Es el mismo objeto body que se obtiene como tercer argumento de la funcion ejecutada cuando se obtiene una respuesta al request realizado.
			headers:		Conjuto de pares de clave-valor de tipo string, que son parte del protocolo HTTP. Son enviados en los requests y son devueltos en el response.
			request:			Información acerca de la solicitud (request) que se acaba de realizar. 
								El request posee un objeto "headers", que contiene los headers que se enviaron desde nuestra aplicación durante la solicitud. 
								En el ejemplo el header del request contiene. "accept": "application/json". 
								Este header se creó cuando en la llamada a request se especificó: json: true.
	
Encoding User Input - Sección 4, clase 31 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525286?start=0

	encodeURLComponent(string)
		
Callback Errors - Sección 4, clase 32 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525288?start=0

Abstracting Callbacks - Sección 4, clase 33 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525290?start=0

Wiring Up Weather Search - Sección 4, clase 34 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525292?start=0

Chaining Callbacks Together - Sección 4, clase 35 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525294?start=0

Intro to ES6 Promises - Sección 4, clase 36 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525296?start=0

Advanced Promises - Sección 4, clase 37 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525306?start=0

Weather App With Promises - Sección 4, clase 38 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525308?start=0

Extra Features - Sección 4, clase 39 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525310?start=0

Section Intro - Sección 5, clase 40 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525312?start=0

Hello Express - Sección 5, clase 41 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525314?start=420

	Instalación con: npm install express --save
	
	Uso e instanciación con:
		const express = requiere('express');
		const app = express();
	
		// Configuración de un handler para un request GET (una ruta):
		app.get('/', (request, response) => {
			// Primer argunmento la url
			// Segundo parametro funcion a ejecutar cuando se haga la peticion a esa url
			//  dicha función posee dos parámetros: request, response
			//  request contiene el cuerpo de la solicitud, los headers, el metodo del request...
			//  response contiene un monton de metodos para responder a la peticion de la manera que uno quiera (html a devolver, statusCode a devolver, etc)
			response.send('<h1>Hola Express!</h1>'); // Permite responser enviando datos de vuelta al cliente.
		});

		// Declaración de otra ruta (handler):
		app.get('/about', (request, response) => {
			response.send('About page');
		})

		// Envio de un objeto JSON:
		app.get('/bad', (req, resp)=> {
			resp.send({
				errorMessage: 'No se pudo completar la solicitud.'
			})
		})

		// app.listen se utiliza para vincular nuestra aplicación a un puerto en nuestra maquina, 
		// para poder recibir peticiones a las rutas configuradas.
		// ******    Hasta que no se ejecuta esa linea, la aplicación no es capaz de recibir ni responder solicitudes.
		app.listen(3000);       // 3000 es el puerto elegido para servir nuestra aplicación, para utilizar navegando a: http://localhost:3000

		// Al ejecutar la aplicación, la misma se queda corriendo, esperando requests a los que responder
		// y nunca se va a detener, hasta que sean presionadas las teclas con CTRL+c


Creating a Web Server - Sección 5, clase 42 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525316?start=0

	Servir un directorio estático con imagenes, css, javascript, etc, sin tener que setear una ruta por cada uno:
		Creación y uso de un Middleware:
			Los Middlewares permiten configurar como funciona una aplicación web hecha con Express, agregando la funcionalidad que queramos como si usaramos un plugin o addon.
		
		Se crea el directorio con contenido estatico deseado, por ej: /public
		Se agrega la llamada app.use() que es la forma que provee Express para permitirnos ejecutar nuestros middlewares.
		Se le pasa en este caso un función provista por Express llamada static:
			app.use( express.static(__dirname + '/public') );
		
"__dirname" almacena la ruta completa a la carpeta raiz del proyecto actual, por lo tanto "__dirname + '/public'" hace referencia a: "c:\proyectoActual\public"

		
Rendering Templates with Data - Sección 5, clase 43 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525318?start=0

	Utilización de un motor de templates con Express: Handlebarsjs.com
	
	Se utiliza junto con Express un modulo que se llama HBS, que permite utilizar Handeblars de una manera más fácil: npmjs.com/package/hbs
	
	Instalación:
		npm install hbs --save
		
	Configuración de Express para que utilice como motor de planitallas a hbs:
		app.set('view engine', 'hbs');
		
	Para guardar las vistas, se crea una carpeta llamada Views (por convención).
		Las mismas son archivos html con extensión .hbs, pero soportan que se les pase un objeto cuando se las renderiza y las propiedades de dicho
			objeto se pueden mostrar en el cliente invocandolas entre doble llaves:		{{mensajeBievenida}}

	Para "renderizarlas" (usarlas), se utilizar en lugar de la llamada a response.send(), la llamada a response.render( nombre de la vista, objeto con datos):
			app.get('/', (request, response) => {
				response.render('home.hbs', {			// El nombre de la vista tal cual existe dentro de la carpeta "views"
				   pageTitle: 'Jom peish',
				   currentYear: new Date().getFullYear(), 
				   welcomeMessage: 'Bienvenido a mi sitio con Noud giés'
			   });
			});
	
Advanced Templating - Sección 5, clase 44 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525320?start=0

	Partials:
		Es una parte parcial del sitio web que se puede reutilizar en distintas paginas.
		
	Se debe configurar hbs para que conozca la carpeta donde estarán los partials:
		hbs.registerPartials(__dirname + '/views/partials/');
	
	En la carpeta /views/partials se deben crear los partials con extensión .hbs, ej:
		footer.hbs:
			<footer>
				<p>Copyright {{currentYear}}</p>
			</footer>
		Como se puede apreciar, los partials pueden utilizar las propiedades de los objetos pasados a las paginas que los invocan o consumen (ej, currentYear).
	
	Para hacer referencia a un partial desde una vista, se deben llamar al partial de la siguiente manera: 		{{> nombreDelPartial }}
		Ej:
			{{> Footer}}
			
	Para que nuestro servidor web se reinicie cada vez que se modifica un partial y se puede ver la modificación enseguida
		se debe ejecutar nodemon con unos flags especiales:
			nodemon server.js -e js,hbs
		con esto se le especifica que debe estar atento a los cambios, para reiniciarse automaticamente, cuando se modifican archivos con extension .js y .hbs (los de las vistas o partials)
	
	Funciones (Helpers) en Handeblars:
		Las funciones se consideran Helpers y se registran en hbs como los partials, pero con una método para tal fin:
			hbs.registerHelper('nombreDeLaFuncionHelper', () => {
				contenido de la función
				debe devolverse el dato con return.
			}
		ej:
			hbs.registerHelper('getFullYear', () => {
				return new Date().getFullYear();
			});
		Luego este 'helper' se puede utilizar desde dentro de las vistas o los partials:
			ej, partial 'footer.hbs':
			<footer>
				<p>Copyright {{getFullYear}}</p>
			</footer>
			
		Los helpers también pueden recibir parametros:
			hbs.registerHelper('aMayusculas', (texto) => {
				return texto.toUpperCase();
			});
		y se puede utilizar así:
			<p>{{ aMayusculas welcomeMessage}}</p>
			
Express Middleware - Sección 5, clase 45 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525322?start=0

	Creación y utilización de middlewares.
	Son funciones que se ejecutan en el medio entre la solicitud del cliente y la respuesta que nuestra aplicación devuelve.
	Se utiliza en su modo mas basico para logueo, pero se puede realizar cualquier validación o procesamiento que se desee.
	Se usan simplemente invocando: app.use( (request, response, next) => {});
		Recibe como parametro una funcion, la cual recibe tres parametros:   request, response y next
		next es una referencia a una funcion que debe ser invocada si o si para que se continue con la ejecucion de la aplicación, por lo que 
		luego de programar la funcionalidad deseada en nuestro middleware, se debe invocar como ultima linea a next();
		en caso de no hacerlo, la aplicación quedará colgada, sin responder ningún tipo de solicitud.
		Request posee toda la información relacionada con la solicitud actual.
		Response esta instanciado pero no está completo (porque falta que sea procesado por el "servidor") y se puede utilizar para por ejemplo finalizar la
			ejecución de la aplicación (por la razón que consideremos) invocando por ej: response.end();
			
	Agregado de un middleware para poner el sitio en mantenimiento, utilizando una vista con un mensaje para informar de tal caso:
		app.use( (req, res, next) => {
			res.render('maintenance.hbs');
		});
		En este caso se renderizará la vista de mantenimiento con un simple titular que informa tal situación.
	IMPORTANTE:
		Este middleware para mostrar el mensaje de mantenimiento DEBE ser llamado ANTES de todas las rutas
		y también ANTES de servir la carpeta con archivos estáticos, sino se va a poder acceder a ellos de todas formas.
		
Adding Version Control (Git) - Sección 5, clase 46 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5525324?start=0

	Descarga e instalación de Git desde http://git-scm.com
	Durante la instalación se debe seleccionar la instalación de Git Bash, ya que permite crear claves SSH para conectarse con los repositorios online.
	Se verifica que esté versión se encuentra instalada ejecutando:
		git --version
		
	Creación de un repositorio:
		Acceder a la carpeta que se desea convertir en un repositorio y ejecutar:
			git init
			con esto se crea una carpeta oculta llamada ".git", que NO se debe modificar por ninguna razón y es donde
			git guarda toda la información sobre el versionado de los archivos del proyecto (la carpeta donde ejecutamos git init).
			
	Verificar estado de los archivos en el repositorio:
		git status
		Apareceran todos los archivos en el proyecto actual que no están siendo versionados
		
	Ignorar archivos con .gitignore
		Se crea este archivo para especificar todos los archivos y carpetas que no se deseean versionar
		Si por ejemplo tenemos un archivo de logs que no deseamos versionar, deberiamos agregar a .gitignore la siguiente linea:
			archivodelog.log
		Lo mismo para carpetas, como la de node_modules por ej:
			node_modules/
		quedando por lo tanto el archivo .gitignore de la siguiente manera:
			logs.log
			node_modules/
		lo que nos asegura de que git no va a tener en cuenta nunca si estos archivos son modificados.
		A partir de este momento, el archivo .gitignore debe ser agregado con git add para que de ahora en mas
		se tenga en cuenta siempre (que git lea dicho archivo) todo lo que git debe ignorar.
		
	Agregar archivos a la supervisión de git y por ende para su versionado:
		Se debe ejecutar:
			git add nombreDeArchivo
			ej:
				git add package.json
		una vez hecho esto, git ya va a comenzar a controlar si ese archivo es modificado y permitirá su versionado (mediante commits)
		Para agregar todo el proyecto al control de versionado de git, se debe ejecutar:
			git add .
		Ahora, si nuevamente se ejecuta:
			git status
			se va a mostrar la lista de archivos que están listos para commitear y también los que no (ya sea porque figuran en .gitignore o porque se crearon luego
			de ejecutar git add .)
	
	Confirmando modificaciones realizadas en el repositorio con Commit:
		Luego de hacer git status se pueden ver los archivos que estan agregados al versionado y listos para commitear (confirmar que se desean versionar en su estado actual)
		Para esto se debe ejecutar:
			git commit -m "algun mensaje sobre el commit, por ejemplo Primer commit"
		una vez realizado esto, los archivos quedan versionados y por mas que luego sean modificados se podrá volver a esta versión especifica de los mismos en cualquier momento.
	
	Luego se puede vincular este repositorio con uno en algún servidor, por ejemplo en github / gitlab / bitbucker, etc con el comando:
		git add remote nombreDelRemote URLDelRemote
	
	También se puede subir el codigo del repositorio al remote con el comando:
		git push origin master
		
		
Real-Time Web Apps with Socket.io

Creating a New Project - Sección 9, clase 105 - https://www.udemy.com/the-complete-nodejs-developer-course-2/learn/v4/t/lecture/5795054?start=0

	Creación de un nuevo proyecto, una aplicación de chat en tiempo real, utilizando Socket.io
	Utilización del modulo integrado en Node llamado Path, el cual detecta y permite armar paths correctos cuando se trabaja desde archivos que están
		en carpetas mas adentro de la raiz del proyecto y se tiene que referenciar carpetas en distintas partes de la estructura de carpetas del proyecto.
	
	Si desde el archivo server.js que se ubica dentro de la carpeta server, se quiere hacer referencia a la carpeta public, que se encuentra en la raiz del proyecto	
		al hacer desde server.js esta llamada:
			console.log(__dirname + '../public');
		se obtiene este resultado:
			C:\CursoNodeUdemy-2nd_Edition-\12_node-chat-app\server../public
		el cual está mal, porque incluye un par de puntos.
		Para esto sirve utilizar el modulo Path de Node, el mismo se utiliza de la siguiente manera:
			const path = require('path');
			console.log(path.join(__dirname, '../public'));
		lo que al ejecutarse devuelve:
			C:\CursoNodeUdemy-2nd_Edition-\12_node-chat-app\public
		esta ruta si es apta para referenciar archivos y carpetas en relación al directorio raiz del proyecto, sin problema alguno.
		
	Servido de archivos estáticos con express:
		const publicPath = path.join(__dirname, '../public');
		const app = express();
		app.use(express.static(publicPath));
	
	/* Extra sacado de la ayuda de git */
		Leer la configuración de git:	https://git-scm.com/book/es/v1/Fundamentos-de-Git-Consejos-y-trucos
			git config --local -l
			git config --global -l
			git config --system -l
		Setear alias:
			git config --global alias.st status				Con esto se puede conocer el status ejecutando: git st 
			git config --global alias.ci commit				Con esto se puede hacer commit ejecutando: git ci -m "mensaje del commit"
			git config --global alias.last 'log -1 HEAD'		Con esto se puede ver el comentario del ultimo commit: git last
			